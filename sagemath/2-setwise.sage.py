

# This file was *autogenerated* from the file ./2-setwise.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9); _sage_const_8 = Integer(8); _sage_const_29 = Integer(29); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10)#!/usr/local/bin/sage

#To run this code, run the command chmod +x three-setwise.sage in the terminal. Then run the command ./three-setwise.sage n key


import sys

def is_derangement(x,P): #input a permutation x and a set P of all partitions of the integer 3 (consisting of)
    u = Permutation(x).cycle_type()
    for y in P:
        if is_submultiset(y,u) == True:
            return False
    return True

def is_submultiset(A,B): #Checks whether A is a submultiset of B
    B = list(B)
    n = len(A)
    a = True
    i = _sage_const_0 
    while i<n and a == True:
        u = A[i]
        if u in B:
            B.remove(u)
        else:
            a = False
        i += _sage_const_1 
    return a

def VA(m):  #initialize the variables that are used in the weightings on the conjugacy classes of Sym(n)
      t = ''
      for i in range(m):
          if i == m-_sage_const_1 :
              t += 'X{0}'.format(i)
          else:
              t += 'X{0},'.format(i)
      return var(t)


# n = argument of Sym(n), k = 3, L = a set of conjugacy classes (as partitions of n), M = a set of partitions of n whose corresponding eigenvalue is -1.
#This function checks whether there is a solution to the system of linear equation of conjugacy classes in L and irreducible characters in M.

def weights(n,k,L,M):
    P = Partitions(k)
    G = SymmetricGroup(n)
    l,m = len(L),len(M)   #L = conjugacy class and M irreducible characters
    #print l,m
    V = VA(m)
    CC_size = []
    char_values = []
    Eq = []
    for F in L:
        for x in SymmetricGroup(n).conjugacy_classes_representatives():
            if x.cycle_type() == F:
                CC_size.append([SymmetricGroup(n).conjugacy_class(x).cardinality(),x])
                break
            else:
                pass
    char = [SymmetricGroupRepresentation(M[i]) for i in range(m)]
    print "--------------------------------------------------------------------------------------------------"
    for chi in char:
        phi = chi#.to_character()
        t = _sage_const_0 
        for i in range(m):
            t += V[i]*phi(CC_size[i][_sage_const_1 ]).trace()*CC_size[i][_sage_const_0 ]
            print chi,V[i],phi(CC_size[i][_sage_const_1 ]).trace(),CC_size[i][_sage_const_1 ].cycle_type()
        if phi == SymmetricGroupRepresentation([n]):
            Eq.append(t == binomial(n,k) -_sage_const_1 )  #The maximum eigenvalue is set to be C(n,k) - 1
        else:
            Eq.append(t == -phi(G[_sage_const_0 ]).trace())  #The eigenvalue corresponding to phi is set to be equal to -1
        print "---------------------------------------------------------------------------------------------------"
    solutions = solve(Eq,V)
    print "\n","Weight possible?", len(solutions) != _sage_const_0 ,"\n"
    if len(solutions) == _sage_const_0 :
        return sys.exit()
##################################################################
    derangement_conjugacy_classes_representatives = []
    CC = G.conjugacy_classes_representatives()
    for x in CC:
        if is_derangement(x,P) == True:
            derangement_conjugacy_classes_representatives.append(x)
    Q = derangement_conjugacy_classes_representatives
    #print len(Q)
    W = [_sage_const_0 ]*len(Q)
    for i in range(len(Q)):
        u = Q[i].cycle_type()
        #print u
        for j in range(m):
            if u == Partition(L[j]):
                W[i] = solutions[_sage_const_0 ][j].rhs()
    print "System of linear equations","\n"
    for x in Eq:
        print x
    print "------------------------------------------------------------------------------------------------","\n"
    print "Weights"
    for x in solutions[_sage_const_0 ]:
        print x
    print "------------------------------------------------------------------------------------------------","\n"
    return [solutions[_sage_const_0 ][i].rhs() for i in range(len(solutions[_sage_const_0 ]))],W #W is the appropriate wgenvalues_weightshtings for the conjugacy classes of derangements


# This function takes a weighting W of the conjugacy classes of derangements and produces eigenvalues of the corresponding weighted spanning subgraph.
# The argument W is the weights of the conjugacy classes of derangements
# key is an option to print the eigenvalues during the computation

def eigenvalues_weights(n,k,W,key):
    print "Computing the eigenvalues ...",'\n',"this might take a few minutes",'\n'

    P = Partitions(k)
    eigenvalues = []
    G = SymmetricGroup(n)
    derangement_conjugacy_classes_representatives = []
    CC = G.conjugacy_classes_representatives()
    for x in CC:
        if is_derangement(x,P) == True:
            derangement_conjugacy_classes_representatives.append(x)
    #print derangement_conjugacy_classes_representatives
    Irr = G.irreducible_characters()#
    #Irr = SymmetricGroupRepresentations(n)
    for psi in Irr:
        #phi = psi.to_character()
        s = _sage_const_0 
        L = derangement_conjugacy_classes_representatives
        for i in range(len(L)):
            s += (_sage_const_1 /psi.degree()) * ( W[i]*G.conjugacy_class(L[i]).cardinality()*psi(L[i]) )
        eigenvalues.append(s)
        if key == 'true':
            print s
        elif key == 'false':
            pass
        else:
            print "Stoped! Set key = true or key = false"
            return sys.exit()

    print "Eigenvalues","\n"
    print len(eigenvalues)
    if n in  [_sage_const_9 ,_sage_const_11 ]:
        A,B,C,D = [eigenvalues[i] for i in [_sage_const_0 ,_sage_const_1 ,_sage_const_2 ,_sage_const_3 ]]
        var('r1,r2')
        new_solutions = solve([A>=-_sage_const_1 ,B>=-_sage_const_1 ,C>=-_sage_const_1 ,D >=-_sage_const_1 ],r1,r2)[_sage_const_5 ]
        a = new_solutions[_sage_const_2 ].lhs()
        b = new_solutions[_sage_const_3 ].rhs()
        A = (a+b)/_sage_const_2 
        c = new_solutions[_sage_const_0 ].lhs().substitute(r2 = A)
        d = new_solutions[_sage_const_1 ].rhs().substitute(r2 = A)
        B = (c+d)/_sage_const_2 
        final_eigenvalues = []
        for x in eigenvalues:
            final_eigenvalues.append(x.substitute(r1 = B,r2 = A))
        print "Eigenvalues for a particular weighting",'\n',final_eigenvalues,'\n'
        print 'The largest eigenvalue is ',max(final_eigenvalues),'\n'
        print 'The least eigenvalue is ',min(final_eigenvalues),'\n'
        print "--------------------------------------------------",'\n','The general eigenvalues are','\n'
    elif n in [_sage_const_6 ,_sage_const_8 ,_sage_const_10 ]:
        A,B,C,D = [eigenvalues[i] for i in [_sage_const_0 ,_sage_const_1 ,_sage_const_2 ,_sage_const_3 ]]
        var('r1,r2')
        new_solutions = solve([A>=-_sage_const_1 ,B>=-_sage_const_1 ,C>=-_sage_const_1 ,D >=-_sage_const_1 ],r1,r2)[_sage_const_0 ]
        a = new_solutions[_sage_const_2 ].lhs()
        b = new_solutions[_sage_const_3 ].rhs()
        A = (a+b)/_sage_const_2 
        c = new_solutions[_sage_const_0 ].lhs().substitute(r2 = A)
        d = new_solutions[_sage_const_1 ].rhs().substitute(r2 = A)
        B = (c+d)/_sage_const_2 
        final_eigenvalues = []
        for x in eigenvalues:
            final_eigenvalues.append(x.substitute(r1 = B,r2 = A))
        print "Eigenvalues for a particular weighting",'\n',final_eigenvalues,'\n'
        print 'The largest eigenvalue is ',max(final_eigenvalues),'\n'
        print 'The least eigenvalue is ',min(final_eigenvalues),'\n'
        print "--------------------------------------------------",'\n','The general eigenvalues are','\n'
    if n in  [_sage_const_7 ]:
        A,B,C,D = [eigenvalues[i] for i in [_sage_const_0 ,_sage_const_1 ,_sage_const_2 ,_sage_const_3 ]]
        var('r1,r2')
        new_solutions = solve([A>=-_sage_const_1 ,B>=-_sage_const_1 ,C>=-_sage_const_1 ,D >=-_sage_const_1 ],r1,r2)[-_sage_const_1 ]
        a = new_solutions[_sage_const_2 ].lhs()
        b = new_solutions[_sage_const_3 ].rhs()
        A = (a+b)/_sage_const_2 
        c = new_solutions[_sage_const_0 ].lhs().substitute(r2 = A)
        d = new_solutions[_sage_const_1 ].rhs().substitute(r2 = A)
        B = (c+d)/_sage_const_2 
        final_eigenvalues = []
        for x in eigenvalues:
            final_eigenvalues.append(x.substitute(r1 = B,r2 = A))
        print "Eigenvalues for a particular weighting",'\n',final_eigenvalues,'\n'
        print 'The largest eigenvalue is ',max(final_eigenvalues),'\n'
        print 'The least eigenvalue is ',min(final_eigenvalues),'\n'
        print "--------------------------------------------------",'\n','The general eigenvalues are','\n'

    return eigenvalues

def is_derangement_on_point(x):
     if len(Permutation(x).fixed_points()) == _sage_const_0 :
         return True
     else:
         return False

def der_graph(G):
    CC = G.conjugacy_classes_representatives()
    D = []
    for x in CC:
        if is_derangement_on_point(x) == True:
            D += G.conjugacy_class(x).list()
    return Graph(G.cayley_graph(generators = D))

#######################
n = int(sys.argv[_sage_const_1 ])
key = sys.argv[_sage_const_2 ] # true or false
k = _sage_const_2 
G = SymmetricGroup(n)
#######################

if n in [_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_6 ]:
    X = graphs.KneserGraph(n,_sage_const_2 )
    X.relabel((ellipsis_range(_sage_const_1 ,Ellipsis,X.order())))
    G = X.automorphism_group()
    if n == _sage_const_4 :
        T = G.conjugacy_classes_subgroups()
        G = T[_sage_const_29 ]
    X = der_graph(G)
    print "The largest intersecting families of Sym({0}) acting on the 2-subsets have size".format(n),X.independent_set(value_only = True)
    Y = X.complement()
    M = Y.cliques_maximum()
    print "Are there maximum non-canonically intersecting families?",len(M)!= G.degree()**_sage_const_2 

if n>=_sage_const_7 :
    W = weights(n,k,[[n],[n-_sage_const_1 ,_sage_const_1 ],[n-_sage_const_3 ,_sage_const_3 ],[n-_sage_const_4 ,_sage_const_3 ,_sage_const_1 ]],[[n],[n-_sage_const_1 ,_sage_const_1 ],[n-_sage_const_2 ,_sage_const_2 ],[n-_sage_const_1 ,_sage_const_1 ]])
    L =  eigenvalues_weights(n,k,W[_sage_const_1 ],key)
    print L


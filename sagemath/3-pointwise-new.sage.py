

# This file was *autogenerated* from the file ./3-pointwise-new.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_4 = Integer(4); _sage_const_8 = Integer(8)#!/usr/local/bin/sage

import numpy as np
import sys

def is_derangement(x): #x is a permutation and P is a set of partitions. If any partition in P is part of the cycle type, then x is not a derangement
    u = Permutation(x).fixed_points()
    if len(u) >=_sage_const_3 :
            return False
    return True

def VA(m):
      t = ''
      for i in range(m):
          if i == m-_sage_const_1 :
              t += 'X{0}'.format(i)
          else:
              t += 'X{0},'.format(i)
      return var(t)

def weights(n,k,L,M):
    P = Partitions(k)
    l,m = len(L),len(M)   #L = conj and M char
    print l,m
    V = VA(m)
    var('z')
    CC_size = []
    char_values = []
    Eq = []
    for F in L:
        for x in SymmetricGroup(n).conjugacy_classes_representatives():
            if x.cycle_type() == F:
                CC_size.append([SymmetricGroup(n).conjugacy_class(x).cardinality(),x])
                break
            else:
                pass
    char = [SymmetricGroupRepresentation(M[i]) for i in range(m)]
    print CC_size
    for chi in char:
        phi = chi.to_character()
        t = _sage_const_0 
        for i in range(m):
            t += V[i]*phi(CC_size[i][_sage_const_1 ])*CC_size[i][_sage_const_0 ]
            print chi,V[i],phi(CC_size[i][_sage_const_1 ]),CC_size[i][_sage_const_1 ].cycle_type()
        if phi.values() == [_sage_const_1 ]*len(SymmetricGroup(n).conjugacy_classes_representatives()):
            Eq.append(t == factorial(k)*binomial(n,k) -_sage_const_1 )  ######## maximum eigenvalue
        else:
            Eq.append(t == -phi.degree())
        Sol = solve(Eq,V)
    print "Weight possible?", len(Sol) != _sage_const_0 
    if len(Sol) == _sage_const_0 :
        return sys.exit()
##################################################################
    G = SymmetricGroup(n)
    derangement_conjugacy_classes_representatives = []
    CC = G.conjugacy_classes_representatives()
    for x in CC:
        if is_derangement(x) == True:
            derangement_conjugacy_classes_representatives.append(x)
    Q = derangement_conjugacy_classes_representatives
    print len(Q)
    W = [_sage_const_0 ]*len(Q)
    for i in range(len(Q)):
        u = Q[i].cycle_type()
        #print u
        for j in range(m):
            if u == Partition(L[j]):
                W[i] = Sol[_sage_const_0 ][j].rhs()
    print "Equation",Eq
    print Sol
    return [Sol[_sage_const_0 ][i].rhs() for i in range(len(Sol[_sage_const_0 ]))],W

def eigenvalues_weights(n,k,W):
    P = Partitions(k)
    eigenvalues = []
    G = SymmetricGroup(n)
    derangement_conjugacy_classes_representatives = []
    CC = G.conjugacy_classes_representatives()
    for x in CC:
        if is_derangement(x) == True:
            derangement_conjugacy_classes_representatives.append(x)
    #print derangement_conjugacy_classes_representatives
    Irr = G.irreducible_characters()#
    #Irr = SymmetricGroupRepresentations(n)
    for psi in Irr:
        #phi = psi.to_character()
        s = _sage_const_0 
        L = derangement_conjugacy_classes_representatives
        for i in range(len(L)):
            s += (_sage_const_1 /psi.degree()) * ( W[i]*G.conjugacy_class(L[i]).cardinality()*psi(L[i]) )
        eigenvalues.append(s)
        #print (s,psi)
    return eigenvalues#,gap.Minimum(eigenvalues)

def DistinctEntries(L):
    return L[_sage_const_0 ] != L[_sage_const_1 ] and L[_sage_const_0 ] != L[_sage_const_2 ] and L[_sage_const_1 ] != L[_sage_const_2 ]

def Triples(n):
    C = Tuples((ellipsis_range(_sage_const_1 ,Ellipsis,n)),_sage_const_3 )
    N = []
    for x in C:
        if DistinctEntries(x) == True:
            N.append(x)
        else:
            pass
    return N

def SymmetricGroupOnTriples(n):
    PermGens = []
    G = SymmetricGroup(n)
    S = G.gens()
    K = label_triples(n)
    L = K[_sage_const_1 ]
    D = K[_sage_const_0 ]
    for g in S:
        N = [_sage_const_0 ]*len(L)
        for x in L:
            i = D[x]
            j = D[action_of_element_as_permutation(g,x)]
            N[i-_sage_const_1 ] = j
        PermGens.append(Permutation(N))
    return PermutationGroup(PermGens)

def action_of_element_as_permutation(f,T):
    return (f(T[_sage_const_0 ]),f(T[_sage_const_1 ]),f(T[_sage_const_2 ]))

def label_triples(n):
    L = [tuple(x) for x in Triples(n)]
    D = dict()
    i = _sage_const_1 
    for x in L:
        D[tuple(x)] = i
        i += _sage_const_1 
    return D,L





n = int(sys.argv[_sage_const_1 ])
k = _sage_const_3 
#W = weights(n,k,[[n],[n-5,4,1],[n-1,1],[n-2,2],[n-6,3,3],[n-2,1,1],[n-3,3]],[[n],[n-1,1],[n-2,2],[n-2,1,1],[n-3,3],[n-3,2,1],[n-3,1,1,1]])
W = weights(n,k,[[n-_sage_const_2 ,_sage_const_1 ,_sage_const_1 ],[n],[n-_sage_const_4 ,_sage_const_3 ,_sage_const_1 ],[n-_sage_const_6 ,_sage_const_3 ,_sage_const_3 ],[n-_sage_const_7 ,_sage_const_4 ,_sage_const_3 ],[n-_sage_const_3 ,_sage_const_2 ,_sage_const_1 ],[n-_sage_const_2 ,_sage_const_2 ],[n-_sage_const_8 ,_sage_const_8 ]],[[n],[n-_sage_const_1 ,_sage_const_1 ],[n-_sage_const_2 ,_sage_const_1 ,_sage_const_1 ],[n-_sage_const_2 ,_sage_const_2 ],[n-_sage_const_3 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ],[n-_sage_const_3 ,_sage_const_2 ,_sage_const_1 ],[n-_sage_const_3 ,_sage_const_3 ],[n-_sage_const_1 ,_sage_const_1 ]])
L =  eigenvalues_weights(n,k,W[_sage_const_1 ])
print L


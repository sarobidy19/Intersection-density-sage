

# This file was *autogenerated* from the file ./agl.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2000 = Integer(2000)#!/usr/local/bin/sage


def vector_to_tuple(x):
    X = []
    for i in x:
        X.append(tuple(i))
    return X

def tuple_to_vector(x):
    X = []
    for i in x:
        X.append(vector(i))
    return X

def action_of_element(A,a,v):
    #print A,v,a
    return A*vector(v) +a

def action_of_element_on_lines(V,A,a,l):
    L = []
    for x in l:
        L.append(action_of_element(A,a,x))
    return set(vector_to_tuple(L))

def label_field(F):
      D = dict()
      i = _sage_const_1 
      for x in F.list():
          D[tuple(x)] = i
          i += _sage_const_1 
      return D

def label_field_for_lines(V,F):
      D = dict()
      i = _sage_const_1 
      for x in F:
          D[i] = set(vector_to_tuple(x))
          i += _sage_const_1 
      return D

def AGL_to_permutation_group_on_points(n,q):
    G = GL(n,GF(q))
    S = VectorSpace(GF(q),n)
    D = label_field(S)
    Ggens = list(G.gens())
    Sbasis = S.basis()
    Group = []
    PermGrp = []
    for A in Ggens:
        for a in Sbasis:
            Group.append((A,a))
    for g in Group:
        N = [_sage_const_0 ]*(q**n)
        for x in S:
            i = D[tuple(x)]
            j = D[tuple(action_of_element(g[_sage_const_0 ],g[_sage_const_1 ],x))]
            N[i-_sage_const_1 ] = j
        PermGrp.append(Permutation(N))
    return PermutationGroup(PermGrp)

def find_line_generators(n,q):
    V = VectorSpace(GF(q),n)
    S = V.list()
    Orbits = []
    while len(S) >_sage_const_1 :
        x = S[_sage_const_0 ]
        N = []
        U = V.subspace([x])
        for y in S:
            if (y in U) == True:
                N.append(y)
            else:
                pass
        Orbits.append(N)
        for z in N:
            S.remove(z)
    s = Orbits[_sage_const_0 ][_sage_const_0 ]
    Orbits.pop(_sage_const_0 )
    for x in Orbits:
        x.append(s)
    return Orbits

def find_line(L):
    Lines = []
    for i in range(len(L)):
        l = L[i]
        lines_generated = []
        if i != _sage_const_0  and i != _sage_const_1 :
            for x in L[_sage_const_0 ]:
                N = []
                for y in l:
                    N.append(y+x)
                lines_generated.append(N)
        elif i == _sage_const_0 :
            for x in L[_sage_const_1 ]:
                N = []
                for y in l:
                    N.append(y+x)
                lines_generated.append(N)
        elif i == _sage_const_1 :
            for x in L[_sage_const_0 ]:
                N = []
                for y in l:
                    N.append(y+x)
                lines_generated.append(N)
        Lines += lines_generated
    return Lines


def AGL_to_permutation_group_on_lines(n,q):
    L = find_line_generators(n,q)
    P = find_line(L)
    G = GL(n,GF(q))
    S = VectorSpace(GF(q),n)
    D = label_field_for_lines(S,P)
    Ggens = list(G.gens())
    Sbasis = S.basis()
    Group = []
    PermGrp = []
    for A in Ggens:
        for a in Sbasis:
            Group.append((A,a))
    for g in Group:
        N = [_sage_const_0 ]*(len(P))
        for i in range(_sage_const_1 ,len(P)+_sage_const_1 ):
            j = D.keys()[D.values().index(action_of_element_on_lines(S,g[_sage_const_0 ],g[_sage_const_1 ],D[i]))]
            #print i,j
            N[i-_sage_const_1 ] = j
        #print N
        PermGrp.append(Permutation(N))
    return PermutationGroup(PermGrp)

def stabilizer_of_blocks(G,L):
    N = []
    Perms = []
    L = G.blocks_all()[_sage_const_0 ]
    L = G.orbit(tuple(L),"OnSets")
    for x in L:
        N.append(G.stabilizer(tuple(x),"OnSets"))
    x = set(N[_sage_const_0 ])
    for s in N:
        x = set(s).intersection(x)
    return PermutationGroup(list(x))

def is_halftransitive(G):
     Z = G.orbits()
     for x in Z:
         if len(x) != len(Z[_sage_const_0 ]):
             return False
     return True
def shifted(U):
     x = U[_sage_const_0 ].inverse()
     return [x*i for i in U]

def stab_union(G):
     H = []
     for i in G.domain():
         H += G.stabilizer(i).list()
     K = set(H)
     return PermutationGroup(list(K))

def FindCocliques(q,k):
    G = AGL_to_permutation_group_on_lines(_sage_const_2 ,q)
    L = find_line_generators(_sage_const_2 ,q)
    L = find_line(L)
    H = stabilizer_of_blocks(G,L)
    U = G.cosets(H)
    Cocliques = []
    SubCosets = Combinations(U,k)
    for i in range(_sage_const_2000 ):
         #i = ZZ.random_element(171230,1712304)
         x = SubCosets[i]
         E = []
         for y in x:
             E += y
         print intersecting(G,E),len(E),i
         if intersecting(G,E) == True:
             Cocliques.append(x)
             break
    return Cocliques

def IntersectingCosets(A,B,H,G):
    Reps = []
    for x in [A,B]:
        Reps.append(x[_sage_const_0 ])
    #print Reps
    for h in H:
        if intersecting(G,[Reps[_sage_const_0 ]*Reps[_sage_const_1 ].inverse(), h]) == False:
            #print Reps[0]*Reps[1].inverse(), h
            return False
        else:
            pass
    return True

def IntersectingAllCosets(T,H,G):
    for x in T:
        for y in T:
            if IntersectingCosets(x,y,H,G) == False and y != x:
                return False
        else:
            pass
    return True

def RatioBound(G):
    K = eigenvalues_group(G)
    return G.order()/(_sage_const_1  - K[_sage_const_2 ]/K[_sage_const_1 ])

def  GraphOfCosets(G,H):
    U = G.cosets(H)
    Reps = []
    for x in U:
        Reps.append(x[_sage_const_0 ])
    X = Graph()
    X.add_vertices(Reps)
    for x in X.vertices():
        for y in X.vertices():
            if x!=y:
                if is_derangement(x*y.inverse()) == True:
                    X.add_edge((y,x))
                else:
                    pass
    return X

def intersecting_on_points(G,L):
    main_key = False
    for i in G.domain():
        N = []
        for x in L:
            N.append(x(i))
        key = True
        a = N[_sage_const_0 ]
        for x in N:
            if x != a:
                key = False
                break
            else:
                pass
        if key == True:
            return key
        else:
            pass
    return main_key

def find_derangement_classes_representatives(G):
    D = []
    CC = G.conjugacy_classes_representatives()
    for x in CC:
        if is_derangement(x) == True:
            D.append(x)
        else:
            pass
    return D

def number_of_derangements(G):
    D = find_derangement_classes_representatives(G)
    Der = []
    for x in D:
        Der += G.conjugacy_class(x).list()
    return len(Der)

def VA(m):
    t = ''
    for i in range(m):
        if i == m-_sage_const_1 :
            t += 'X{0}'.format(i)
        else:
            t += 'X{0},'.format(i)
    return var(t)

def weights(G,L,M):
    #G = AGL_to_permutation_group_on_lines(2,q)
    l,m = len(L),len(M)   #L = conj and M char
    print l,m
    V = VA(m)
    var('z')
    CC_size = []
    char_values = []
    Eq = []
    for F in L:
        #for x in find_derangement_classes_representatives(G):
            #if x == F:
                x = F
                CC_size.append([G.conjugacy_class(x).cardinality(),x])
            #    break
            #else:
                pass
    char = M   #[SymmetricGroupRepresentation(M[i]) for i in range(m)]
    print CC_size
    for chi in char:
        phi = chi
        t = _sage_const_0 
        for i in range(m):
            t += V[i]*phi(CC_size[i][_sage_const_1 ])*CC_size[i][_sage_const_0 ]
            print V[i],phi(CC_size[i][_sage_const_1 ])#,CC_size[i][1].cycle_type()
        if phi.values() == [_sage_const_1 ]*len(G.conjugacy_classes_representatives()):
            Eq.append(t == G.degree() -_sage_const_1 )  ######## maximum eigenvalue
        else:
            Eq.append(t == -phi.degree())
        Sol = solve(Eq,V)
    print "Weight possible?", len(Sol) != _sage_const_0 
    if len(Sol) == _sage_const_0 :
        return False
##################################################################
    Q = find_derangement_classes_representatives(G)
    print len(Q)
    W = [_sage_const_0 ]*len(Q)
    for i in range(len(Q)):
        u = Q[i]
        #print u
        for j in range(m):
            if u == L[j]:
                W[i] = Sol[_sage_const_0 ][j].rhs()
    print "Equation",Eq
    print Sol
    return [Sol[_sage_const_0 ][i].rhs() for i in range(len(Sol[_sage_const_0 ]))],W

def eigenvalues_weights(G,W):
    eigenvalues = []
    derangement_conjugacy_classes_representatives = find_derangement_classes_representatives(G)
    #print derangement_conjugacy_classes_representatives
    Irr = G.irreducible_characters()#
    #Irr = SymmetricGroupRepresentations(n)
    for psi in Irr:
        #phi = psi.to_character()
        s = _sage_const_0 
        L = derangement_conjugacy_classes_representatives
        for i in range(len(L)):
            s += (_sage_const_1 /psi.degree()) * ( W[i]*G.conjugacy_class(L[i]).cardinality()*psi(L[i]) )
        eigenvalues.append(s)
        print s
    return eigenvalues,gap.Minimum(eigenvalues)

def Run(q):
    G = AGL_to_permutation_group_on_lines(_sage_const_2 ,q)
    print G.order()
    S = G.conjugacy_classes_subgroups()
    Good = []
    for x in S:
        if x.is_transitive() == True:
             Good.append(x)
    Good.pop(len(Good)-_sage_const_1 )
    print len(Good)
    Great = []
    for x in Good:
         print x.order()
         #H = stab_union(G)
         if x.order() != (q**_sage_const_2 -_sage_const_1 )*q**_sage_const_2 :
             pass
         else:
             H = stab_union(x)
             print intersecting(G,H) == True, x.structure_description()
             Great.append(x)

def is_derangement(x):
     if len(Permutation(x).fixed_points()) == _sage_const_0 :
         return True
     else:
         return False


def stab_union(G):
     H = []
     for i in G.domain():
         H += G.stabilizer(i).list()
     K = set(H)
     return PermutationGroup(list(K))

def regularity(G,F):
    N = []
    n = len(G.domain())
    for i in range(_sage_const_1 ,n+_sage_const_1 ):
        for j in range(_sage_const_1 ,n+_sage_const_1 ):
            M = []
            for x in F:
                if x(i) == j:
                    M.append(x)
            N.append((i,j,len(M)))
            print ((i,j,len(M)))
    #return N

def intersecting(G,F):
     n = len(G.domain())
     for x in F:
         for y in F:
             a = 'intersecting'
             for i in range(_sage_const_1 ,n+_sage_const_1 ):
                 if x(i) == y(i):
                     a = 'intersecting'
                     #print x,y,i
                     break
                 else:
                     a = 'not-intersecting'
                     pass
             if a == 'intersecting':
                 pass
             else:
                 #print (x,y)
                 return False
     return True


q = sys.argv[_sage_const_1 ]
Run(int(q))


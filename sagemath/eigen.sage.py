
# This file was *autogenerated* from the file ./eigen.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0)#!/usr/local/bin/sage

import numpy as np

def get_derangements(G):
    Drep = []
    D = []
    CC = G.conjugacy_classes_representatives()
    for x in CC:
        if is_derangement(G,x) == True:
            Drep.append(x)
        else:
            pass
    for x in Drep:
          D += list(G.conjugacy_class(x))
    return D
    #return filter(is_derangement,G)
def is_derangement(G,x):
    for i in G.domain():
        if x(i) == i:
            return False
        else:
            pass
    return True

def eigenvalues_group(G):
    IRR = G.irreducible_characters()
    derangement_conjugacy_classes_representatives = []
    eigenvalues = []
    CC = G.conjugacy_classes_representatives()
    for x in CC:
        if is_derangement(G,x) == True:
            derangement_conjugacy_classes_representatives.append(x)
    for phi in IRR:
        s = _sage_const_0 
        for x in derangement_conjugacy_classes_representatives:
            s += (_sage_const_1 /phi.degree()) * ( G.conjugacy_class(x).cardinality()*phi(x) )
        eigenvalues.append(s)
    return eigenvalues

def derangement_graph(G):
    X = G.cayley_graph(generators = get_derangements(G))
    return Graph(X)

def min_list(L):
    t = L[_sage_const_0 ]
    for j in range(len(L)):
        print L[j],t,t-L[j]>_sage_const_0 
        if t-L[j]>_sage_const_0 :
            t = L[j]
        else:
            pass
        #print t
    print "t_min=",t
    return t

def max_list(L):
    s = L[_sage_const_0 ]
    for i in L:
        if i>s:
            s = i
    return s

def test_graph(X):
    X.relabel()
    G = X.automorphism_group()
    Y = derangement_graph(G)
    independent_number = Y.independent_set(value_only = True)
    clique_number = Y.clique_number()
    eigenvalues = list(eigenvalues_group(G))
    print "max=",max_list(eigenvalues),"min =", min_list(eigenvalues)
    print "-----------------------------"
    print "\n Independence number = ",independent_number, "\n stabilizer = ",G.stabilizer(_sage_const_1 ).order(),"\n transitive", X.is_vertex_transitive(),"\n clique-coclique =", float(G.order()/clique_number)
    #print "ratio bound = ",ratio_bound(G)
    #return eigenvalues

def ratio_bound(G):
    eigenvalues = eigenvalues_group(G)
    A = eigenvalues
    return float(G.order()/(_sage_const_1  - (max(A)/(min(A)))))
def test_graphs(L):
    for i in range(len(L)):
        X = L[i]
        X.relabel()
        G = X.automorphism_group()
        Y = derangement_graph(G)
        independent_number = Y.independent_set(value_only = True)
        clique_number = Y.clique_number()
        eigenvalues = list(eigenvalues_group(G))
        print max_list(eigenvalues),min_list(eigenvalues)
        print "-----------------------------"
        print "\t No",int(i+_sage_const_1 )
        print "\n Independence number = ",independent_number, "\n stabilizer = ",G.stabilizer(_sage_const_1 ).order(),"\n transitive", X.is_vertex_transitive(),"\n clique-coclique =", float(G.order()/clique_number), "\n ratio bound = ", float(G.order()/(_sage_const_1  - (max(eigenvalues)/(min(eigenvalues)))))
    return min(eigenvalues)

#LL = [graphs.CompleteGraph(5)]
test_graph(graphs.CoxeterGraph())

